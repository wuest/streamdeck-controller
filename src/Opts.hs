{-# LANGUAGE OverloadedStrings #-}

module Opts ( Options (..)
            , getOpts
            ) where
 
import Prelude
import System.Console.GetOpt

import qualified Streamdeck         as SD  (vendorID, productID)
import qualified Data.Word          as DW  (Word16)
import qualified Text.Printf        as P   (printf)

import System.Environment (getProgName, getArgs, getEnvironment)
import System.IO          (hPutStrLn, stderr)
import System.Exit        (exitSuccess)

import qualified System.Directory as Dir
import qualified Const

data Options = Options { optVerbose :: Bool
                       , webPort    :: Int
                       , baseDir    :: IO FilePath
                       }

showUDev :: Options -> IO Options
showUDev _ = do
    hPutStrLn stderr $ unlines
        [ "# Global access UDEV file for Elgato Stream Deck Generated by streamdeck-controller"
        , "#"
        , "# Install to /etc/udev/rules.d/elgato.rules to assign rw-rw-rw- permissions to"
        , "# all Stream Deck devices."
        , "#"
        , "# See https://github.com/wuest/streamdeck-controller/blob/master/README.md for more"
        , "# information."
        , ""
        , line "SUBSYSTEM" "usb" SD.vendorID SD.productID
        , line "KERNEL" "hidraw*" SD.vendorID SD.productID
        ]
    exitSuccess
  where
    line :: String -> String -> DW.Word16 -> DW.Word16 -> String
    line = P.printf "%s==\"%s\", ATTRS{idVendor}==\"%04x\", ATTRS{idProduct}==\"%04x\", MODE=\"0666\""

defaultOptions :: Options
defaultOptions =
    Options { optVerbose = False
            , webPort    = 3000
            , baseDir    = Dir.getXdgDirectory Dir.XdgData Const.applicationName
            }

printVersion :: Options -> IO Options
printVersion _ = do
    hPutStrLn stderr $ Const.applicationName ++ " " ++ Const.version
    exitSuccess

printHelp :: Options -> IO Options
printHelp _ = do
    prg <- getProgName
    hPutStrLn stderr (usageInfo prg options)
    exitSuccess

baseDirLocation :: FilePath -> Options -> IO Options
baseDirLocation arg opt = return opt { baseDir = Dir.makeAbsolute arg }

verbose :: Options -> IO Options
verbose opt = return opt { optVerbose = True }

setWebPort :: String -> Options -> IO Options
setWebPort arg opt = return opt { webPort = read arg :: Int }

blank :: OptDescr (Options -> IO Options)
blank = Option [] [] (NoArg return) ""

options :: [ OptDescr (Options -> IO Options) ]
options =
    [ Option ['v'] ["verbose"]
        (NoArg verbose) "Enable verbose messages"

    , Option ['V'] ["version"]
        (NoArg printVersion) "Print version"

    , Option ['h', '?'] ["help"]
        (NoArg printHelp) "Show help"
    , blank

    , Option [] ["udev"]
        (NoArg showUDev) "Generate udev configuration file for globally accessible Stream Decks"

    , blank

    , Option ['b'] ["base"]
        (ReqArg baseDirLocation "DATABASE") "Base asset location"

    , Option ['p'] ["webport"]
        (ReqArg setWebPort "PORT") "Port for the webserver to run on"
    ]

processEnv :: Options -> (String, String) -> Options
processEnv opt _ = opt

getOpts :: IO Options
getOpts = do
    args <- getArgs
    env <- getEnvironment
    let (actions, _nonoptions, _errors) = getOpt RequireOrder options args
        envOpts = foldl processEnv defaultOptions env
    foldl (>>=) (return envOpts) actions
